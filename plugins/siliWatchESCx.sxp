"""
 siliWatchESCx.sxp

 The siliWatch SXAPI plugin for ESCx controllers.

 This module is part of the YOS/SWTools project.

 TODO:
    The plugin makes a blocking, periodic calls to the SXAPI to retrieve the values.
    Because of that, the UI responsivity depends on the comlink load.
    An obvious solution is to extend the SXAPI with asynchronous callbacks
    (for 'get' method, similarly like current 'execute' method offers),
    and then make use of event-driven architecture, as used elsewhere in the system.
    A simpler workaround might be to adjust the 'iomode' property.

 Date:
    2024

 Copyright:
    siliXcon (c) all rights reserved. Redistribution and usage of this code
    in another project without the author's agreement is not allowed.
"""

import tkinter, customtkinter, math, csv, time
import os # for file explorer after logging ends
import webbrowser # for opening external url with help
from PIL import Image
from tkinter import filedialog
from datetime import datetime
from siliUX import codetostr
from siliUX import find_nodes
from siliUX.messagebox import *
#from siliUX.ctk_tooltip import *



'''
import gc
import sys
import threading
import time
from collections import defaultdict

class MemoryMonitor:
    def __init__(self, interval=5):
        self.interval = interval
        self.running = False
        self.thread = None
    
    def get_object_counts(self):
        counts = defaultdict(int)
        for obj in gc.get_objects():
            counts[type(obj).__name__] += 1
        return counts

    def get_size(self, obj):
        """Get size of object and its contents"""
        try:
            return sys.getsizeof(obj)
        except:
            return 0

    def get_total_memory(self):
        """Estimate total memory used by Python objects"""
        total_size = 0
        for obj in gc.get_objects():
            total_size += self.get_size(obj)
        return total_size
    
    def monitor(self):
        while self.running:
            counts = self.get_object_counts()
            total_mem = self.get_total_memory()

            print(f"\nTotal Memory Used: {total_mem / 1024 / 1024:.2f} MB")
            print("\nTop 10 Object counts:")
            for type_name, count in sorted(counts.items(), key=lambda x: x[1], reverse=True)[:10]:
                print(f"{type_name}: {count}")
            print("-" * 40)
            
            time.sleep(self.interval)

    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self.monitor, daemon=True)
        self.thread.start()
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join()
'''

lib_dir = os.path.dirname(__file__) + "/siliUX/"

def icon(name):
    pil_image = Image.open(lib_dir + name)
    return customtkinter.CTkImage(pil_image, size = pil_image.size)
    #return tkinter.PhotoImage(file=lib_dir + name)

nodes, nodenames = find_nodes.find("esc")

################################################################################
# log callbacks

logfile = None
writer = None
log_count = 0
log_prio = 4
log_row = []
log_switches = []

# do not change the order, indices are defined within registration
log_group = [
    "battery and motor currents",
    "battery and motor voltages",
    "total stator current",
    "total stator voltage",
    "motor speed",
    "command and mode",
    "command multipliers",
    "power throughput",
    "error, stat, limit and totallimit",
    "temperatures",
]

################################################################################
# log callbacks


class state_monitor:
    def __init__(self, prio, log_id, path, cb):
        global my_node
        self.path = path
        self.cb = cb
        self.prio = prio - 1
        self.log_id = log_id
        self.variable = my_node.variable(self.path)

    def update(self, *args):
        value = self.variable.get()
        self.cb(value)
        return value


update_timer = None
current_index = 0
current_prio = 0


def update():
    global update_timer, updaters, current_index, current_prio, log_prio, log_count, log_row

    try:
        while True:
            updater = updaters[current_index]
            current_index = current_index + 1
            if current_index >= len(updaters):
                # TODO consider spreading current_prio randomly (from 0 - 4) - to not aggregate log samples together
                app.nodeselect_button.configure(selected_color="green")
                current_prio = (current_prio + 1) % 5
                current_index = 0
                if logfile and writer and log_prio <= current_prio:
                    if log_count >= 0:
                        if log_switches[2].get():
                            log_row.append(motcurrent)
                        if log_switches[3].get():
                            log_row.append(motvoltage)
                    writer.writerow(log_row)
                    log_count = log_count + 1
                    app.logcountlabel.configure(text=str(log_count) + " samples")
                    # start over
                    log_row = [datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")]

            if updater.prio <= current_prio:
                # TODO try to experiment with different iomodes here (read the header above)
                # we can attempt to schedule and IO op and if not successful, repeat next time. That will promote responsivity.
                # Also try the 'direct' mode (not to disturb emGUI).
                value = updater.update()
                if logfile and writer and log_prio <= current_prio and updater.log_id >= 0 and log_switches[updater.log_id].get() and log_count >= 0:
                    log_row.append(value)
                break

        update_timer = app.after(10, update)

    except sxapi.error as e:
        app.nodeselect_button.configure(selected_color="red")
        # attempt to recover
        # NOTE if device is disconnected, this makes the gui to freeze for 1 second. Use different iomode !
        update_timer = app.after(3456, update)
        raise e

################################################################################
# updaters - contextes

modes = [
    "FRW",
    "VLT",
    "CRT",
    "VLF",
    "VLB",
    "SCR",
    "TRQ",
    "DCR",
    "BRK",
    "BRT",
    "BRF",
    "RES",
    "RES",
    "RES",
    "SVC",
    "SHR",
]

error = 0
stat = 0
iref = 0
cmd = 0
currentq = 0
currentd = 0
voltageq = 0
voltaged = 0

supplyvoltage = 0
supplycurrent = 0

vector = 1

# localy calculated - for logging
motvoltage = 0
motcurrent = 0

# needed for in-lambda setting
def set_global_var(var_name, value):
    globals()[var_name] = value
    #locals()[var_name] = value

################################################################################
# make the main window and node select callback

#customtkinter.deactivate_automatic_dpi_awareness()
app = customtkinter.CTk()
app.title("siliWatch (ESCx)")
#app.attributes("-topmost", 1)
#x, y = app.winfo_pointerxy()
#app.geometry(f"{850}x{750}+{x-425}+{y}")
app.grid_columnconfigure(1, weight=1)
app.grid_columnconfigure((2, 3), weight=0)
app.grid_rowconfigure(3, weight=1)
app.grid_rowconfigure(4, weight=1)
app.iconbitmap(lib_dir + "SiliXcon.ico")
#app.attributes("-topmost", 0)

def node_select_callback(nodename):
    global update_timer
    if update_timer:
        app.after_cancel(update_timer)

    app.enablebar.configure(fg_color="black", progress_color="black")
    app.totallimitbar.configure(progress_color="black")
    app.imultbar.configure(progress_color="black")
    app.umultbar.configure(progress_color="black")    
    app.nodeselect_button.configure(selected_color="red")
    app.modelabel.configure(text=" UNK")
    app.statlabel.configure(fg_color="transparent")
    app.limitlabel.configure(fg_color="transparent")
    app.errorlabel.configure(fg_color="transparent")
    app.motcurrentbar.configure(progress_color="black")
    app.motvoltagebar.configure(progress_color="black")
    # app.term_button.configure(state="disabled")
    # app.scope_button.configure(state="disabled")

    if nodename in nodenames:
        global my_node, updaters
        my_node = nodes[nodenames.index(nodename)]
        # app.term_button.configure(state="enabled")
        # app.scope_button.configure(state="enabled")
        updaters = []

        try:
            # one time reference param read
            set_global_var("iref",  my_node.variable("/driver/iref").get())
            # TODO consider reading uref as well

            # handle some of the exceptions - some variables are named differently in esc3 and esc5
            # TODO add support for esc4 and esc6 !
            try:
                updaters.append(state_monitor(1, 7, "/driver/power", lambda value: (
                    app.pwrlabel.configure(text=str(int(value)) + "W")
                ))) # esc3

            except sxapi.error as e:
                updaters.append(state_monitor(1, 7, "/driver/powerf", lambda value: (
                    app.pwrlabel.configure(text=str(int(value)) + "W")
                ))) # esc5

            # limiters & status words

            updaters.append(state_monitor(1, 8, "/driver/error", lambda value: (
                set_global_var("error", value),
                app.errortext.delete("0.0", "end"),  # delete all text
                app.errortext.insert("0.0", codetostr.error2string(value)),
                app.errorlabel.configure(text="error\n" + str(value), fg_color="red" if value else "transparent")
            )))
            updaters.append(state_monitor(1, -1, "/driver/enable", lambda value: (
                app.enablebar.configure(fg_color="grey", progress_color="blue" if value else "grey")
            )))
            updaters.append(state_monitor(1, 8, "/driver/stat", lambda value: (
                set_global_var("stat", value),
                app.stattext.delete("0.0", "end"),  # delete all text
                app.stattext.insert("0.0", codetostr.stat2string(value)),
                app.statlabel.configure(text="stat\n" + str(value), fg_color="darkorange" if value else "transparent")
            )))
            updaters.append(state_monitor(1, 8, "/driver/limit", lambda value: (
                app.limittext.delete("0.0", "end"),  # delete all text
                app.limittext.insert("0.0", codetostr.limit2string(value)),
                app.limitlabel.configure(text="limit\n" + str(value), fg_color="green" if value else "transparent")
            )))
            updaters.append(state_monitor(1, 8, "/driver/totallimit", lambda value: (
                app.totallimitbar.configure(progress_color="red" if error else "yellow" if stat else "green"),
                app.totallimitbar.set(value)
            )))

            # command

            updaters.append(state_monitor(3, 5, "/driver/cmd", lambda value: (
                set_global_var("cmd", value),
                app.cmdbar.set(value)
            )))
            updaters.append(state_monitor(3, 5, "/driver/mode", lambda value: (
                app.modelabel.configure(text=" " + modes[value & 15] + " " + str(round(cmd, 2))),
                app.checkbox_pos.configure(state="enabled"),
                app.checkbox_spd.configure(state="enabled"),
                app.checkbox_spd.select() if value & 0x10 else app.checkbox_spd.deselect(),
                app.checkbox_pos.select() if value & 0x20 else app.checkbox_pos.deselect(),
                app.checkbox_pos.configure(state="disabled"),
                app.checkbox_spd.configure(state="disabled")
            )))
            try:
                updaters.append(state_monitor(3, 6, "/driver/iqmult", lambda value: (
                    app.imultbar.set(value),
                    app.imultbar.configure(progress_color="green")
                )))  # VECTOR
            except sxapi.error as e:
                updaters.append(state_monitor(3, 6, "/driver/imult", lambda value: (
                    app.imultbar.set(value),
                    app.imultbar.configure(progress_color="green")
                )))  # BLDC
            try:
                updaters.append(state_monitor(3, 6, "/driver/uqmult", lambda value: (
                    app.umultbar.set(value),
                    app.umultbar.configure(progress_color="yellow")
                )))  # VECTOR
            except sxapi.error as e:
                updaters.append(state_monitor(3, 6, "/driver/umult", lambda value: (
                    app.umultbar.set(value),
                    app.umultbar.configure(progress_color="yellow")         
                )))  # BLDC

            # temps and energy counter

            updaters.append(state_monitor(4, 9, "/driver/temp", lambda value: (
                app.templabel.configure(text=str(round(value, 1)) + "\N{DEGREE SIGN}C")
            )))
            updaters.append(state_monitor(4, 9, "/driver/ptctemp", lambda val: (
                app.ptctemplabel.configure(text=str("N/A") if math.isnan(val) else str("INF") if math.isinf(val) else str(int(val)))
            )))
            updaters.append(state_monitor(4, -1, "/driver/energy", lambda value: (
                app.energylabel.configure(text=str(int(value)) + "J")
            )))

            #supply

            updaters.append(state_monitor(2, 0, "/driver/supply/currentf", lambda value: (
                set_global_var("supplycurrent", value),
                app.batcurrentbar.set(value / iref) if iref else None
            )))
            updaters.append(state_monitor(2, 1, "/driver/supply/voltage", lambda value: (
                set_global_var("supplyvoltage", value),
                app.battlabel.configure(text=" " + str(round(supplyvoltage, 2)) + "V\n " + str(round(supplycurrent, 2)) + "A")
            )))

            # supply counters

            updaters.append(state_monitor(5, -1, "/driver/supply/cap", lambda value: (
                app.coulomblabel.configure(text=str(int(value)) + "mAh")
            )))

            # motor

            try: # VECTOR
                updaters.append(state_monitor(2, 0, "/driver/motor/currentqf", lambda value: (
                     set_global_var("currentq", value),
                     set_global_var("vector", 1)
                )))
                updaters.append(state_monitor(2, 0, "/driver/motor/currentdf", lambda value: (
                    set_global_var("currentd", value),
                    set_global_var("motcurrent", math.sqrt(currentq * currentq + currentd * currentd)),

                    app.motcurrentlabel.configure(text=str(round(motcurrent, 2)) + "A / " + str(round(motcurrent / 1.41, 2)) + "Arms"),
                    app.motcurrentbar.configure(progress_color="green"), # TODO is it necessary?
                    app.motcurrentbar.set(motcurrent / iref) if iref else None,

                    app.fluxlabel.configure(text=str(round(voltaged, 2)) + "V\n" + str(round(currentd, 1)) + "A"),
                )))
            except sxapi.error as e: # BLDC
                updaters.append(state_monitor(2, 0, "/driver/motor/current", lambda value: (
                    set_global_var("currentq", value),
                    set_global_var("motcurrent", value),

                    app.motcurrentlabel.configure(text=str(round(motcurrent, 2)) + "A / " + str(round(motcurrent, 2)) + "Arms"),
                    app.motcurrentbar.configure(progress_color="green"), # TODO is it necessary?
                    app.motcurrentbar.set(motcurrent / iref) if iref else None,

                    app.fluxlabel.configure(text="N/A"),
                    set_global_var("vector", 0)
                )))

            try: # VECTOR
                updaters.append(state_monitor(2, 1, "/driver/motor/voltageq", lambda value: (
                    set_global_var("voltageq", value),
                    app.torquelabel.configure(text=str(round(voltageq, 2)) + "V\n" + str(round(currentq, 1)) + "A")
                )))

                updaters.append(state_monitor(2, 1, "/driver/motor/voltaged", lambda value: (
                    set_global_var("voltaged", value),
                    set_global_var("motvoltage", (math.sqrt(voltageq * voltageq + voltaged * voltaged) * 1.73205)),  # sqrt3

                    app.motvoltagelabel.configure(text=str(round(motvoltage, 2)) + "V / " + str(round(motvoltage / 1.41, 2)) + "Vrms"),
                    app.motvoltagebar.configure(progress_color="yellow"), # TODO is it necessary?
                    app.motvoltagebar.set(motvoltage / supplyvoltage) if supplyvoltage else None
                )))
            except sxapi.error as e: # BLDC
                updaters.append(state_monitor(2, 1, "/driver/motor/voltage", lambda value: (
                    set_global_var("motvoltage", value),

                    app.motvoltagelabel.configure(text=str(round(motvoltage, 2)) + "V / " + str(round(motvoltage / 1.41, 2)) + "Vrms"),
                    app.motvoltagebar.configure(progress_color="yellow"), # TODO is it necessary?
                    app.motvoltagebar.set(motvoltage / supplyvoltage) if supplyvoltage else None,

                    app.torquelabel.configure(text=str(round(motvoltage, 2)) + "V\n" + str(round(motcurrent, 1)) + "A")
                )))

            updaters.append(state_monitor(2, 4, "/driver/motor/rpmf", lambda value: (
                app.rpmlabel.configure(text=" " + str(int(value)) + "\n RPM")
            )))

            # motor counters

            updaters.append(state_monitor(4, -1, "/driver/motor/odo", lambda value: (
                app.odolabel.configure(text=str(value) + " revs")
            )))
            updaters.append(state_monitor(4, 9, "/driver/motor/Rthermistor", lambda value: (
                app.ohmlabel.configure(text=str("N/A") if math.isnan(value) else str("INF") if math.isinf(value) else str(int(value)) + " ohms")
            )))

            #indicate success

            update_timer = app.after(567, update)

        except sxapi.error as e:
            MessageBox(app, title="siliWatch", cls=2,
                message="The firmware is not compatible or you do not have enough rights.\n"
                + str(e))


################################################################################
# create top frame

app.top_frame = customtkinter.CTkFrame(app, fg_color="transparent")
app.top_frame.grid(row=0, column=0, columnspan=8, padx=(10, 10), pady=(10, 10), sticky="sew")
app.top_frame.grid_columnconfigure((3, 4, 5), weight=1)


def show_emgui():
    sxapi.show()


emgui_switch = customtkinter.CTkButton(
    app.top_frame,
    text=f"emgui",
    command=show_emgui,
    image=icon("main.png"),
    width=5,
)
emgui_switch.grid(row=0, column=0, padx=(10, 0))

scope_open = 0
def open_scope():
    global scope_open
    scope_open = 1
    my_node.open("{scope}")


scope_button = customtkinter.CTkButton(
    app.top_frame,
    text="scope",
    command=open_scope,
    image=icon("scope.png"),
    width=5,
)
scope_button.grid(row=0, column=1, padx=(10, 0), sticky="w")

# def open_term():
#    my_node.open("{term}")

# term_button = customtkinter.CTkButton(app.top_frame, text="term", command=open_term, image=icon("term.png"), width=5)
# term_button.grid(row=0, column=2, padx=(10,0))


app.nodeselect_label = customtkinter.CTkLabel(
    app.top_frame,
    text="Device:",
    font=customtkinter.CTkFont(size=15, weight="bold"),
)
app.nodeselect_label.grid(row=0, column=3, padx=10, sticky="e")

app.nodeselect_button = customtkinter.CTkSegmentedButton(
    app.top_frame, command=node_select_callback
)
app.nodeselect_button.grid(row=0, column=4, sticky="w")
app.nodeselect_button.configure(values=nodenames + ["NONE"])


help_button = customtkinter.CTkButton(
    app.top_frame,
    text=f"",
    image=icon("help.png"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/plugins/siliWatch")),
    width=5,
)
help_button.grid(row=0, column=5, padx=5, pady=5, sticky="e")


icon_light = icon("light.png")
icon_dark = icon("dark.png")

def change_appearance_mode_event():
    if customtkinter.get_appearance_mode() == "Dark":
        customtkinter.set_appearance_mode("Light")
        apperance_switch.configure(image=icon_dark)
    else:
        customtkinter.set_appearance_mode("Dark")
        apperance_switch.configure(image=icon_light)


apperance_switch = customtkinter.CTkButton(
    app.top_frame,
    text=f"",
    command=change_appearance_mode_event,
    image=icon_dark,
    width=5,
)
apperance_switch.grid(row=0, column=6, padx=5, pady=5, sticky="e")

def change_ontop_event():
    if ontop_switch.cget("border_width"):
        app.attributes("-topmost", 0)
        ontop_switch.configure(border_width=0)
    else:
        app.attributes("-topmost", 1)
        ontop_switch.configure(border_width=3)
        
ontop_switch = customtkinter.CTkButton(
    app.top_frame,
    text=f"",
    command=change_ontop_event,
    image=icon("address.png"),
    width=5,
)
ontop_switch.grid(row=0, column=7, padx=5, pady=0, sticky="e")

################################################################################
# create sidebar frame with widgets

app.sidebar_frame = customtkinter.CTkFrame(app, fg_color="transparent")
app.sidebar_frame.grid(row=1, column=0, rowspan=4, padx=5, pady=5, sticky="nsew")
app.sidebar_frame.grid_rowconfigure(1, weight=1)


################################################################################
# create scrollable frame - logging

def log_swcheck_event():
    count = 0
    for i in range(len(log_group)):
        if log_switches[i].get() == 1:
            count = count + 1
    if count:
        app.logctl_button.configure(state="enabled")
    else:
        app.logctl_button.configure(state="disabled")


def log_selectall_event():
    for i in range(len(log_group)):
        log_switches[i].select()
    app.logctl_button.configure(state="enabled")


def log_selectnone_event():
    for i in range(len(log_group)):
        log_switches[i].deselect()
    app.logctl_button.configure(state="disabled")


def log_open_event():
    global logfile_path

    if logfile_path:
        # Construct the command to open the file explorer
        if os.name == "nt":  # Windows
            os.startfile(logfile_path)
        elif os.name == "posix":  # macOS and Linux
            os.system(f'open "{logfile_path}"')


def log_ctl_event(value):
    global logfile_path, logfile, writer, log_count, log_row, log_prio

    if logfile and value == "Stop":
        # app.entry.configure(state="normal")
        for i in range(len(log_group)):
            log_switches[i].configure(state="normal")

        logfile.close()
        logfile = 0
        app.logctl_button.configure(selected_color="green")
        app.showfile_button.configure(
            state="enabled", text=f"Show " + os.path.basename(logfile_path)
        )
        app.delimiter.configure(state="enabled")
        app.selectall.configure(state="enabled")
        app.selectnone.configure(state="enabled")

    elif value == "Record":
        logfile_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
        )

        # user cancelled the file selection dialog
        if not logfile_path:
            app.logctl_button.set("Stop")
            return

        try:
            logfile = open(logfile_path, mode="w", newline="")

        # file could not be opened
        except Exception as e:
            app.logctl_button.set("Stop")
            return

        if app.delimiter.get() == 1:
            writer = csv.writer(logfile, delimiter=";")
        else:
            writer = csv.writer(logfile)
        # app.entry.configure(state="readonly")

        log_row = ["timestamp"]

        for i in range(len(log_group)):
            log_switches[i].configure(state="disabled")

        log_prio = 0
        for i in range(len(updaters)):
            updater = updaters[i]
            if updater.log_id >= 0 and log_switches[updater.log_id].get():
                log_row.append(updater.path)
                if updater.prio > log_prio:
                    log_prio = updater.prio

        if log_switches[2].get():
            log_row.append("stator current")
        if log_switches[3].get():
            log_row.append("stator voltage")

        log_count = -1

        app.logctl_button.configure(selected_color="red")
        app.showfile_button.configure(state="disabled")
        app.delimiter.configure(state="disabled")
        app.selectall.configure(state="disabled")
        app.selectnone.configure(state="disabled")


app.scrollable_frame = customtkinter.CTkScrollableFrame(app.sidebar_frame) #label_text="Data recording" )

app.scrollable_frame.grid(row=1, column=0, columnspan=2, pady=5, sticky="nsew")
app.scrollable_frame.grid_columnconfigure(1, weight=0)


# app.logctl_button = customtkinter.CTkButton(app.scrollable_frame, text=f"Record ...", width=5, command=log_ctl_event, fg_color="green", state="disabled")
app.logctl_button = customtkinter.CTkSegmentedButton(
    app.scrollable_frame, command=log_ctl_event
)
app.logctl_button.configure(
    values=["Stop", "Record"], selected_color="green", state="disabled"
)
app.logctl_button.set("Stop")
app.logctl_button.grid(row=0, column=0, pady=5, padx=5)


app.logcountlabel = customtkinter.CTkLabel(
    app.scrollable_frame,
    text="0 samples",
    font=customtkinter.CTkFont(size=15, weight="bold"),
)
app.logcountlabel.grid(row=0, column=1, padx=5, sticky="nsew")
#CTkToolTip(app.logcountlabel, message="Samples recorded")

app.delimiter = customtkinter.CTkSwitch(
    master=app.scrollable_frame, text="use semicolon delimiter"
)
app.delimiter.grid(row=1, column=0, columnspan=2, pady=5, padx=5, sticky="nw")

app.showfile_button = customtkinter.CTkButton(
    app.scrollable_frame,
    text=f"Show recorded data",
    command=log_open_event,
    state="disabled",
)
app.showfile_button.grid(row=2, column=0, columnspan=2, pady=5, padx=5)

# app.entry = customtkinter.CTkEntry(app.scrollable_frame)
# app.entry.grid(row=1, column=0, columnspan=2, pady=5, sticky="we")
# app.entry.insert(0, "log.csv")
# CTkToolTip(app.entry, message="File name to record to.")

for i in range(len(log_group)):
    switch = customtkinter.CTkCheckBox(
        master=app.scrollable_frame, text=log_group[i], command=log_swcheck_event
    )
    switch.grid(row=i + 5, column=0, columnspan=2, pady=5, sticky="w")
    log_switches.append(switch)

app.selectall = customtkinter.CTkButton(
    app.scrollable_frame,
    text=f"Select all",
    width=5,
    command=log_selectall_event,
    border_width=3,
)
app.selectall.grid(row=33, column=0, pady=5, sticky="w")

app.selectnone = customtkinter.CTkButton(
    app.scrollable_frame,
    text=f"Select none",
    width=5,
    command=log_selectnone_event,
    border_width=3,
)
app.selectnone.grid(row=34, column=0, pady=5, sticky="w")


################################################################################
# create scope control tabview

app.tabview = customtkinter.CTkTabview(app.sidebar_frame, width=200, height=200)
app.tabview.grid(row=0, column=0, columnspan=2, pady=5, sticky="nsew")


def plot_plot(val, index):
    ret = -1
    if val == "battery current":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/supply/currentf")
    if val == "motor currents":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/currentqf", "/driver/motor/currentdf")
        else:  # BLDC
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/current")
    if val == "unfiltered motor currents":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/currentq", "/driver/motor/currentd")
        else:  # BLDC
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/current")
    if val == "motor current references":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/debug_core/Iqref", "/driver/debug_core/Idref")
        else:  # BLDC
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/debug_core/currentr")  # TODO !
    if val == "battery voltage":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/supply/voltage")
    if val == "motor voltages":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/voltageq", "/driver/motor/voltaged")
        else:  # BLDC
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/voltage", "/driver/motor/duty")
    if val == "motor voltage references":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/debug_core/Uqref", "/driver/debug_core/Udref")
        else:  # BLDC
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/debug_core/dutyr")  # TODO !
    if val == "power":
        if vector:  # VECTOR
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/powerf")
        else:
            ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/power")
    if val == "motor speed":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/rpmf")
    if val == "tempreatures":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/temp", "/driver/ptctemp")
    if val == "motor temperature (resistance)":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/motor/rthermistor")
    if val == "stat and limit":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/stat", "/driver/limit")
    if val == "totallimit":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/totallimit")
    if val == "command and mode":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/cmd", "/driver/mode")
    if val == "command multipliers":
        ret = my_node.executeSimple("plot", "-p" + str(index), "/driver/iqmult", "/driver/uqmult")

    if ret < 0:
        MessageBox(app, title="siliWatch", cls=2, message="Could not plot the variable(s).\n")

class plot_tab:
    index = 0
    user_event = None

    def release_event(self):
        my_node.executeSimple("legend", "-p" + str(self.index), "-c20", "99", "113")

    def autoset_event(self):
        my_node.executeSimple(
            "legend", "-p" + str(self.index), "-c24", "13", "0"
        )  # a bug workaround: YOS only sends payload in multiply of 4 bytes, we must send a dummy zero

    def state_update(self):
        plot_state = my_node.executeSimple("period", "-p" + str(self.index), "-g", "-c")
        self.clear_button.configure(text="Clear\n" + str((plot_state >> 16) & 7))

    def clear_event(self):
        my_node.executeSimple("plot", "-p" + str(self.index), "-c")
        self.state_update()

    def period_event(self, val):
        my_node.executeSimple("period", "-p" + str(self.index), val.split(" ", 1)[0])
        self.state_update()

    def plot_event(self, val):
        self.valuemenu.set("Plot a topic ...")
        autoscale = 1
        global scope_open
        if scope_open == 0:
            scope_open = 1
            my_node.executeSimple("clear", "all")
            my_node.open("{scope} -t")
            time.sleep(1)

        else:
            my_node.open("{scope}")
            #time.sleep(0.5)

            # reset if nothing is running in the scope
            if (my_node.executeSimple("period", "-p" + str(self.index), "-g", "-c") >> 16) & 7 == 0:
                my_node.executeSimple("legend", "-p" + str(self.index), "-c20", "99", "112")
                time.sleep(0.5)
                autoscale = 0

        plot_plot(val, self.index)

        # do autoscale
        if autoscale:
            time.sleep(0.5)
            my_node.executeSimple("legend", "-p" + str(self.index), "-c24", "13", "0")  # a bug workaround: YOS only sends payload in multiply of 4 bytes, we must send a dummy zero

        self.state_update()

    def __init__(self, name, idx, vals):
        app.tabview.add(name)
        app.tabview.tab(name).grid_columnconfigure((0, 1, 2, 3), weight=1)
        self.index = idx
        self.valuemenu = customtkinter.CTkOptionMenu(
            app.tabview.tab(name),
            dynamic_resizing=False,
            values=vals,
            command=self.plot_event,
        )
        self.valuemenu.grid(row=0, column=0, columnspan=3, padx=10, pady=(20, 10))
        self.valuemenu.set("Plot a topic ...")
        #CTkToolTip(self.valuemenu, message="Choose group of variables to plot.")
        self.periodbox = customtkinter.CTkComboBox(
            app.tabview.tab(name),
            values=["1 ms", "2 ms", "5 ms", "10 ms", "20 ms", "50 ms", "100 ms"],
            command=self.period_event,
        )
        self.periodbox.set("10 ms")
        self.periodbox.grid(row=1, column=0, columnspan=3, padx=10, pady=10)
        #CTkToolTip(self.periodbox, message="Choose a sampling period for this plot.")
        self.clear_button = customtkinter.CTkButton(
            app.tabview.tab(name),
            text="Clear",
            command=self.clear_event,
            border_width=2,
            width=5,
        )
        self.clear_button.grid(row=0, column=3, rowspan=2, padx=5, pady=5)
        #CTkToolTip(self.clear_button, message="Clear the plot (stop sampling service).")
        self.release_button = customtkinter.CTkButton(
            app.tabview.tab(name), text="Release", command=self.release_event, width=5
        )
        self.release_button.grid(
            row=2, column=2, columnspan=2, padx=5, pady=5, sticky="w"
        )
        #CTkToolTip(self.release_button, message="Release this plot from the scope.")
        self.autoset_button = customtkinter.CTkButton(
            app.tabview.tab(name), text="Autoscale", command=self.autoset_event, width=5
        )
        self.autoset_button.grid(
            row=2, column=0, columnspan=2, padx=5, pady=5, sticky="e"
        )
        #CTkToolTip(self.autoset_button, message="Auto-scale this plot according to the acutal data.")


plot_groups = [
    "battery current",
    "motor currents",
    "unfiltered motor currents",
    "motor current references",
    "battery voltage",
    "motor voltages",
    "motor voltage references",
    "power",
    "motor speed",
    "tempreatures",
    "motor temperature (resistance)",
    "stat and limit",
    "totallimit",
    "command and mode",
    "command multipliers",
]

plot0 = plot_tab("plot0", 0, plot_groups)
plot1 = plot_tab("plot1", 1, plot_groups)
plot2 = plot_tab("plot2", 2, plot_groups)
plot3 = plot_tab("plot3", 3, plot_groups)


################################################################################
# create driver powerstage frame

app.drv_frame = customtkinter.CTkFrame(app)
app.drv_frame.grid(row=1, column=1, padx=5, pady=5, sticky="nsew")
app.drv_frame.grid_columnconfigure(1, weight=1)
app.drv_frame.grid_rowconfigure(1, weight=1)

app.namelabel = customtkinter.CTkButton(
    app.drv_frame, text="Power stage", corner_radius=5, fg_color=("gray78", "gray23"), text_color=("gray23", "gray78"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/measurements")),
)
app.namelabel.grid(row=0, column=0, columnspan=3, sticky="ew")

app.templabel = customtkinter.CTkLabel(
    app.drv_frame,
    text="0\N{DEGREE SIGN}C",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("temp.png"),
    compound="left",
)
app.templabel.grid(row=1, column=0, rowspan=3, padx=0, sticky="w")
#CTkToolTip(app.templabel, message="Average temperature.")

app.pwrlabel = customtkinter.CTkLabel(
    app.drv_frame,
    text="0W",
    pady=5,
    font=customtkinter.CTkFont(size=40, weight="bold"),
    image=icon("transistor.png"),
    compound="left",
)
app.pwrlabel.grid(row=1, column=1)
#CTkToolTip(app.pwrlabel, message="Total power throughput.")

app.energylabel = customtkinter.CTkLabel(
    app.drv_frame,
    text="0J",
    image=icon("counter.png"),
    compound="left",
)
app.energylabel.grid(row=2, column=1)
#CTkToolTip(app.energylabel, message="Transferred energy since reboot.")

app.ptctemplabel = customtkinter.CTkLabel(
    app.drv_frame,
    text="0",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("templimit.png"),
    compound="left",
)
app.ptctemplabel.grid(row=1, column=2, rowspan=3, padx=(0, 20), sticky="e")
#CTkToolTip(app.ptctemplabel, message="Peak temperature sensor state.")

# TODO consider other widget to indicate enable state (e.g. icon)
app.enablebar = customtkinter.CTkProgressBar(app.drv_frame, orientation="horizontal")
app.enablebar.grid(row=3, column=1, padx=5, pady=5, sticky="ns")
app.enablebar.configure(
    #progress_color="black", fg_color="black"
)  # , mode="indeterminate")
app.enablebar.set(1)
#CTkToolTip(app.enablebar, message="Power transistor switching state.")

# app.enablebar.start()

################################################################################
# create limter/stat/error view frame

app.limiter_frame = customtkinter.CTkFrame(app)
app.limiter_frame.grid(row=2, column=1, rowspan=2, padx=5, pady=5, sticky="nsew")
app.limiter_frame.grid_columnconfigure((0, 1, 2), weight=1)
app.limiter_frame.grid_rowconfigure(2, weight=1)

app.namelabel = customtkinter.CTkButton(
    app.limiter_frame,
    text="Diagnostics, protection and derating",
    corner_radius=5,
    fg_color=("gray78", "gray23"), text_color=("gray23", "gray78"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/protections")),
)
app.namelabel.grid(row=0, column=0, columnspan=3, sticky="ew")

app.errorlabel = customtkinter.CTkLabel(
    app.limiter_frame,
    text="error\n0",
    corner_radius=5,
    image=icon("stop.png"),
    width=120,
    compound="left",
    #text_color=("black", "white"), command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/diagnostic/driver_error")),
)
app.errorlabel.grid(row=1, column=0, padx=5, pady=5, sticky="nw")

app.errortext = customtkinter.CTkTextbox(app.limiter_frame)  # , state="disabled")
app.errortext.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")
#CTkToolTip(app.errorlabel, message="Driver critical error.")

app.statlabel = customtkinter.CTkLabel(
    app.limiter_frame,
    text="stat\n0",
    corner_radius=5,
    image=icon("warning.png"),
    width=120,
    compound="left",
    #text_color=("black", "white"),  command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/protections/driver_state")),
)
app.statlabel.grid(row=1, column=1, padx=5, pady=5, sticky="nw")

app.stattext = customtkinter.CTkTextbox(app.limiter_frame)  # , state="disabled")
app.stattext.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")
#CTkToolTip(app.statlabel, message="Driver status (warning) indication.")

app.limitlabel = customtkinter.CTkLabel(
    app.limiter_frame,
    text="limit\n0",
    corner_radius=5,
    image=icon("limiter.png"),
    width=120,
    compound="left",
    # text_color=("black", "white"), command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/limiters/limiter_word")),
)
app.limitlabel.grid(row=1, column=2, padx=5, pady=5, sticky="nw")

app.limittext = customtkinter.CTkTextbox(app.limiter_frame)  # , state="disabled")
app.limittext.grid(row=2, column=2, padx=5, pady=5, sticky="nsew")
#CTkToolTip(app.limitlabel, message="Driver limit (derating) indication.")

app.totallimitbar = customtkinter.CTkProgressBar(
    app.limiter_frame, height=20 #, progress_color="black"
)
app.totallimitbar.grid(row=3, column=0, columnspan=3, padx=5, pady=5, sticky="ew")
app.totallimitbar.set(1)
#CTkToolTip(app.totallimitbar, message="Total driver limitation.")

################################################################################
# create driver command frame

app.cmd_frame = customtkinter.CTkFrame(app)
app.cmd_frame.grid(row=4, column=1, padx=5, pady=5, sticky="nsew")
app.cmd_frame.grid_columnconfigure(2, weight=1)
app.cmd_frame.grid_rowconfigure(1, weight=2)

app.namelabel = customtkinter.CTkButton(
    app.cmd_frame,
    text="Actual drive command",
    corner_radius=5,
    fg_color=("gray78", "gray23"), text_color=("gray23", "gray78"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/command")),
)
app.namelabel.grid(row=0, column=0, columnspan=4, sticky="ew")

app.imultbar = customtkinter.CTkProgressBar(app.cmd_frame, orientation="vertical")
app.imultbar.grid(row=1, column=0, rowspan=3, padx=5, pady=5, sticky="ns")
#CTkToolTip(app.imultbar, message="Current multiplier level.")

app.checkbox_spd = customtkinter.CTkSwitch(
    master=app.cmd_frame, text="speed loop", state="disabled", button_color="grey"
)
app.checkbox_spd.grid(row=3, column=1, pady=5, padx=20, sticky="nw")
app.checkbox_pos = customtkinter.CTkSwitch(
    master=app.cmd_frame, text="position loop", state="disabled", button_color="grey"
)
app.checkbox_pos.grid(row=3, column=2, pady=5, padx=20, sticky="nw")


app.modelabel = customtkinter.CTkButton(
    app.cmd_frame,
    text=" UNK",
    font=customtkinter.CTkFont(size=40, weight="bold"),
    image=icon("joystick.png"),
    compound="left",
    fg_color="transparent", text_color=("black", "white"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/command/driver_mode")),
)
app.modelabel.grid(row=1, column=0, columnspan=3, pady=5)

#CTkToolTip(app.modelabel, message="Actual drive mode.")

# app.cmdlabel = customtkinter.CTkLabel(app.cmd_frame, text="0.0", font=customtkinter.CTkFont(size=40, weight="bold"))
# app.cmdlabel.grid(row=0, column=0, columnspan=2)

app.cmdbar = customtkinter.CTkSlider(
    app.cmd_frame,
    from_=-1,
    to=1,
    state="disabled",
    progress_color="transparent",
    button_color="grey",
    height=30,
)
app.cmdbar.grid(row=2, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
#CTkToolTip(app.cmdbar, message="Actual drive level.")

app.umultbar = customtkinter.CTkProgressBar(app.cmd_frame, orientation="vertical")
app.umultbar.grid(row=1, column=3, rowspan=3, padx=5, pady=5, sticky="ns")
#CTkToolTip(app.umultbar, message="Voltage multiplier level.")

# app.rmultbar = customtkinter.CTkProgressBar(app.cmd_frame, orientation="vertical")
# app.rmultbar.grid(row=0, column=4, rowspan=4, padx=(10, 10), pady=(10, 10), sticky="ns")


################################################################################
# create battery frame

app.battery_frame = customtkinter.CTkFrame(app)
app.battery_frame.grid(row=1, column=2, rowspan=2, padx=5, pady=5, sticky="nsew")
app.battery_frame.grid_columnconfigure(0, weight=1)
app.battery_frame.grid_rowconfigure(1, weight=1)

app.namelabel = customtkinter.CTkButton(
    app.battery_frame,
    text="Supply (DC)",
    corner_radius=5,
    fg_color=("gray78", "gray23"), text_color=("gray23", "gray78"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/supply")),
)
app.namelabel.grid(row=0, column=0, columnspan=3, sticky="ew")

app.battlabel = customtkinter.CTkLabel(
    app.battery_frame,
    text="0.0V\n0.0A",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("battery.png"),
    compound="left",
)
app.battlabel.grid(row=1, column=0, pady=10, padx=(30, 0), sticky="w")

app.coulomblabel = customtkinter.CTkLabel(
    app.battery_frame,
    text="0mAh",
    image=icon("counter.png"),
    compound="left",
)
app.coulomblabel.grid(row=2, column=0)
#CTkToolTip(app.coulomblabel, message="DC capacity transferred since last reboot.")

app.batcurrentbar = customtkinter.CTkSlider(
    app.battery_frame,
    from_=-1,
    to=1,
    state="disabled",
    progress_color="transparent",
    button_color="grey",
    height=30,
)
app.batcurrentbar.grid(row=3, column=0, padx=(10, 10), pady=(10, 10), sticky="ns")
#CTkToolTip(app.batcurrentbar, message="Relative DC current indicator.")

################################################################################
# create motor frame

app.motor_frame = customtkinter.CTkFrame(app)
app.motor_frame.grid(row=3, column=2, rowspan=2, padx=5, pady=5, sticky="nsew")
app.motor_frame.grid_columnconfigure(0, weight=1)
app.motor_frame.grid_columnconfigure(1, weight=1)
app.motor_frame.grid_rowconfigure((1, 3, 5, 7, 11), weight=1)

app.namelabel = customtkinter.CTkButton(
    app.motor_frame, text="Motor (AC)", corner_radius=5, fg_color=("gray78", "gray23"), text_color=("gray23", "gray78"),
    command = lambda : (webbrowser.open("https://docs.silixcon.com/docs/fw/modules/esc/driver/motor")),
)
app.namelabel.grid(row=0, column=0, columnspan=3, sticky="ew")

app.rpmlabel = customtkinter.CTkLabel(
    app.motor_frame,
    text="0\nRPM",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("motor.png"),
    compound="left",
)
app.rpmlabel.grid(row=1, column=0, columnspan=2, sticky="nsew")

app.fluxlabel = customtkinter.CTkLabel(
    app.motor_frame,
    text="0A\0V",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("flux.png"),
    compound="top",
)
app.fluxlabel.grid(row=3, column=0, sticky="nsew")
#CTkToolTip(app.fluxlabel, message="D-axis (flux) current and voltage.")

app.torquelabel = customtkinter.CTkLabel(
    app.motor_frame,
    text="0A\0V",
    font=customtkinter.CTkFont(size=20, weight="bold"),
    image=icon("torque.png"),
    compound="top",
)
app.torquelabel.grid(row=3, column=1, sticky="nsew")
#CTkToolTip(app.torquelabel, message="Q-axis (torque) current and voltage.")

app.motvoltagelabel = customtkinter.CTkLabel(app.motor_frame, text="0V / 0Vrms")
app.motvoltagelabel.grid(row=5, column=0, columnspan=2, pady=(0, 0))
#CTkToolTip(app.motvoltagelabel, message="Stator voltage (magnitude and RMS).")

app.motvoltagebar = customtkinter.CTkProgressBar(app.motor_frame, height=10)
app.motvoltagebar.grid(row=6, column=0, columnspan=2, pady=(0, 10), sticky="ns")

app.motcurrentlabel = customtkinter.CTkLabel(app.motor_frame, text="0A / 0Arms")
app.motcurrentlabel.grid(row=7, column=0, columnspan=2, pady=(10, 0))
#CTkToolTip(app.motcurrentlabel, message="Stator current (magnitude and RMS).")

app.motcurrentbar = customtkinter.CTkProgressBar(app.motor_frame, height=10)
app.motcurrentbar.grid(row=9, column=0, columnspan=2, pady=(0, 0), sticky="ns")

app.odolabel = customtkinter.CTkLabel(
    app.motor_frame,
    text="0 revs",
    image=icon("counter.png"),
    compound="top",
)
app.odolabel.grid(row=11, column=0, pady=15)
#CTkToolTip(app.odolabel, message="Number of electrical revolutions since reboot.")

app.ohmlabel = customtkinter.CTkLabel(
    app.motor_frame,
    text="0 ohms",
    image=icon("ohm.png"),
    compound="top",
)
app.ohmlabel.grid(row=11, column=1, pady=15)
#CTkToolTip(app.ohmlabel, message="Resistance of the motor temperature sensor.")


################################################################################
# start the loop !

# if a single node is fetched, load it automatically
if len(nodenames) == 1:
    app.nodeselect_button.set(nodenames[0])
    node_select_callback(nodenames[0])
else:
    app.nodeselect_button.set("NONE")
    node_select_callback("NONE")

#monitor = MemoryMonitor(interval=1)  # Print every 5 seconds
#monitor.start()
    
app.mainloop()
